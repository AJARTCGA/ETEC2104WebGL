<!DOCTYPE html>
<!-- saved from url=(0076)https://www.ssucet.org/pluginfile.php/1109/mod_resource/content/0/icube.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>OOSE WebGL Test #1</title>
<script type="text/javascript" src="./iCube_files/gl-matrix-min.js"></script><style type="text/css"></style>
<script type="text/javascript" src="./iCube_files/vs.js"></script><style type="text/css"></style>
<script type="text/javascript" src="./iCube_files/fs.js"></script><style type="text/css"></style>
</head>

<body class=" hasGoogleVoiceExt">
<canvas id="MainCanvas" width="400" height="400"></canvas>
<script type="text/javascript">
document.addEventListener('keydown', function(event) {
//w
    if(event.keyCode == 87) {
        anim1 = true;
    }
//a
    if(event.keyCode == 65) {
        anim2 = true;
    }
//s
	if(event.keyCode == 83) {
        anim3 = true;
    }
//d
	if(event.keyCode == 68) {
        alert('Right was pressed');
    }
});
document.addEventListener('keyup', function(event) {
//w
    if(event.keyCode == 87) {
        anim1 = false;
    }
//a
    if(event.keyCode == 65) {
        anim2 = false;
    }
//s
	if(event.keyCode == 83) {
        anim3 = false;
    }
//d
	if(event.keyCode == 68) {
        alert('Right was pressed');
    }
});
var canvas = document.getElementById('MainCanvas');
var ctx = canvas.getContext('webgl');
ctx.viewport(0, 0, 400, 400);
ctx.clearColor(0.8, 0.8, 0.8, 1.0);
ctx.clear(ctx.COLOR_BUFFER_BIT);
canvas.style.top = '0px';
canvas.style.position = 'absolute';
canvas.style.left = '0px';
canvas.style.margin = '0px';
canvas.width = window.innerHeight;
canvas.height = window.innerHeight;


var vsp = ctx.createShader(ctx.VERTEX_SHADER);
ctx.shaderSource(vsp, vs);
ctx.compileShader(vsp);

var fsp = ctx.createShader(ctx.FRAGMENT_SHADER);
ctx.shaderSource(fsp, fs);
ctx.compileShader(fsp);

var shaderProgram = ctx.createProgram();
ctx.attachShader(shaderProgram, vsp);
ctx.attachShader(shaderProgram, fsp);
ctx.linkProgram(shaderProgram);

ctx.useProgram(shaderProgram);

var vertpa = ctx.getAttribLocation(shaderProgram, 'vertexPosition');
ctx.enableVertexAttribArray(vertpa);



var vBuff = ctx.createBuffer();
ctx.bindBuffer(ctx.ARRAY_BUFFER, vBuff);
				 
var vertices =[1.0, 1.0, -1.0, 
				-1.0,1.0,-1.0,
				-1.0,-1.0,-1.0,
				1.0,-1.0,-1.0,
				1.0, 1.0, 1.0, 
				-1.0,1.0,1.0,
				-1.0,-1.0,1.0,
				1.0,-1.0,1.0];

var indices = [0,1, 1,2, 2,3, 3,0,
				4,5, 5,6, 6,7, 7,4,
				0,4, 1,5, 2,6, 3,7];
				
ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(vertices), ctx.STATIC_DRAW);
ctx.vertexAttribPointer(vertpa, 3, ctx.FLOAT, false, 0, 0);


var iBuff = ctx.createBuffer();
ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, iBuff);
ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, new Int16Array(indices), ctx.STATIC_DRAW);

function get_projection(angle, a, zMin, zMax) {
var ang = Math.tan((angle*.5)*Math.PI/180);
return [
   0.5/ang, 0 , 0, 0,
   0, 0.5*a/ang, 0, 0,
   0, 0, -(zMax+zMin)/(zMax-zMin), -1,
   0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 ];
}
	
var projMatrix = get_projection(40, canvas.width/canvas.height, 1, 100);
//mat4.perspective(projMatrix, Math.PI / 4, canvas.width/canvas.height, 1, 100);
var worldMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
var viewMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
//viewMatrix[14] = viewMatrix[14] - 6;
var worldMLoc = ctx.getUniformLocation(shaderProgram, 'worldMatrix');
var viewMLoc = ctx.getUniformLocation(shaderProgram, 'viewMatrix');
var projMLoc = ctx.getUniformLocation(shaderProgram, 'projMatrix');

console.log(worldMatrix);
console.log(viewMatrix);
console.log(projMatrix);
var time_old = 0;
var lastMat = 0;
var rotMatrix = mat4.create();
var translationMatrix = mat4.create();
var timer = 0.0;
var anim1 = false;
var anim2 = false;
var anim3 = false;
var anim4 = false;

var animate = function(time) 
{
	elapsed = time - time_old;
	time_old = time;
	worldMatrix = mat4.create();
	//mat4.rotateX(rotMatrix, rotMatrix, Math.PI * elapsed * 0.0003);
	//mat4.rotateY(rotMatrix, mat4.create(), Math.PI/4);
	
	//if(timer < Math.PI * 2)
	if(anim1)
	{
		mat4.rotateX(rotMatrix, rotMatrix, Math.PI * elapsed*0.001);
	}
	//else if(timer > Math.PI * 2 && timer < Math.PI * 4 )
	if(anim2)
	{
		mat4.rotateY(rotMatrix, rotMatrix, Math.PI * elapsed*0.001);
	}
	//else if(timer > Math.PI * 4 && timer < Math.PI * 6)
	if(anim3)
	{
		mat4.rotateZ(rotMatrix, rotMatrix, Math.PI * elapsed*0.001);
	}
	/*
	else if(anim4)
	{
		mat4.rotateZ(rotMatrix, rotMatrix, Math.PI * elapsed * 0.0003);
	}
	*/
	//timer += Math.PI * elapsed * 0.0003;
	if(timer > Math.PI * 6)
	{
		timer = 0.0;
	}
//	anim1 = false;
//anim2 = false;
//anim3 = false;
	//console.log("rot: " + rotMatrix);
	
	//mat4.translate(worldMatrix, mat4.create(),[0,0,-6]);
	//console.log("world:" + worldMatrix);
	mat4.translate(translationMatrix, mat4.create(), [0,0,-3]);
	//worldMatrix = mat4.clone(translationMatrix);
	mat4.transpose(translationMatrix, translationMatrix);
	mat4.mul(worldMatrix, rotMatrix, translationMatrix);
	//console.log();
	//mat4.multiply(worldMatrix, translationMatrix, rotMatrix);
	//console.log(rotMatrix);
	//console.log(worldMatrix);
	ctx.uniformMatrix4fv(worldMLoc,false,worldMatrix);
	ctx.uniformMatrix4fv(viewMLoc,false,viewMatrix);
	ctx.uniformMatrix4fv(projMLoc,false,projMatrix);

	ctx.enable(ctx.BLEND);
	ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);

	ctx.viewport(0, 0, canvas.width, canvas.height);
	ctx.clear(ctx.COLOR_BUFFER_BIT);
	ctx.drawElements(ctx.LINES, indices.length, ctx.UNSIGNED_SHORT,0);
	window.requestAnimationFrame(animate);
}
animate(0);

</script>


</body></html>